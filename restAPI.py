from flask_restful import Api, Resource, reqparse
from fileAdapter import FileAdapter
from filter import filter, sort
import json


# Cached API requests
release_requests = {}
adapter = FileAdapter()
releases = adapter.getReleases()

#-------------------------Helper Functions----------------------------#

# Checks if request arguments are in cache
def in_cache(args):
    start_date = hex(int(args['start_date']))
    end_date = hex(int(args['end_date']))
    datetype = str(args['datetype'])
    state = str(int(args['state']))
    label = str(args['label'])
    sort_method = str(int(args['sort_method']))
    key = start_date + end_date + datetype + state + label + sort_method # creates an autogenerated key for memcache

    if key in release_requests:
        return key, release_requests[key]
    else:
        return False, key


#-------------------------REST API----------------------------#

class Releases(Resource):
    def get(self):
        result = json.dumps(releases)
        return result, 200


class Pagination(Resource):
    def post(self):
        # parse the post request for the requisite info
        parser = reqparse.RequestParser()
        parser.add_argument('start_date')
        parser.add_argument('end_date')
        parser.add_argument('datetype')
        parser.add_argument('state')
        parser.add_argument('label')
        parser.add_argument('sort_method')
        parser.add_argument('limit')
        parser.add_argument('offset')
        args = parser.parse_args()

        #check if limit and offset exists, if not, provide the first 100 releases
        if not args['limit']:
            args['limit'] = 100

        if not args['offset']:
            args['offset'] = 0

        # checks if the filtered, sorted data is already in memcache
        cache_exists, cache_results = in_cache(args)
        if cache_exists:
            return json.dumps(cache_results[int(args['offset']):(int(args['limit'])+int(args['offset']))])
        else:
            response = filter(releases, args['state'], args['label'], args['start_date'], args['end_date'], args['datetype'])
            response = sort(response, args['sort_method'])
            release_requests[cache_results] = response

            # time adds an expiration time of one hour, in order to keep the memcache somewhat up to date
            return json.dumps(response[int(args['offset']):(int(args['limit'])+int(args['offset']))])


class GetLabels(Resource):
    def get(self):
        labels = adapter.getLabels()
        return json.dumps(labels)
