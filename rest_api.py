"""REST API."""
import datetime
import json
from airflow_connector import AirflowDB
from file_adapter import FileAdapter
from filter_releases import filter_releases
from filter_releases import sort
from flask_restful import reqparse
from flask_restful import Resource


adapter = FileAdapter()
adapter.load_releases('fake_release_data.json')
adapter.load_tasks('fake_task_data.json')
release_requests = {}
# initiate a connection with the airflow database
airflow_db = AirflowDB(CLOUDSQL_CONNECTION_NAME='istio-release-ui:us-central1:prod-airflow-snapshot-sandbox',  # pylint: disable=line-too-long
                       CLOUDSQL_USER='root',
                       CLOUDSQL_PASSWORD='',
                       CLOUDSQL_HOST='35.193.234.53',
                       CLOUDSQL_DB='airflow-db')


def in_cache(args):
  """Checks if request arguments are in cache."""

  start_date = hex(int(args['start_date']))
  end_date = hex(int(args['end_date']))
  datetype = str(args['datetype'])
  state = str(int(args['state']))
  label = str(args['label'])
  sort_method = str(int(args['sort_method']))
  # create an autogenerated key for memcache
  key = start_date + end_date + datetype + state + label + sort_method

  if key in release_requests:
    return key, release_requests[key]
  else:
    return False, key


class Releases(Resource):
  """"Resource for all releases GET request."""

  def get(self):
    # parse the post request for the requisite info
    parser = reqparse.RequestParser()
    parser.add_argument('start_date')
    parser.add_argument('end_date')
    parser.add_argument('datetype')
    parser.add_argument('state')
    parser.add_argument('label')
    parser.add_argument('sort_method')
    parser.add_argument('limit')
    parser.add_argument('offset')
    args = parser.parse_args()

    # check if limit and offset exists, if not, provide the first 100 releases
    if not args['limit']:
      args['limit'] = 100

    if not args['offset']:
      args['offset'] = 0

    array_from = int(args['offset'])
    array_to = int(args['limit'])+int(args['offset'])
    # checks if the filtered, sorted data is already in memcache
    cache_exists, cache_results = in_cache(args)
    if cache_exists:
      return json.dumps(cache_results[array_from:array_to])
    else:
      response = filter_releases(adapter.get_releases(), args['state'], args['label'], args['start_date'], args['end_date'], args['datetype'])  # pylint: disable=line-too-long
      if args['end_date'] == 0:
        response = sort(response, args['sort_method'])
      release_requests[cache_results] = response

      return json.dumps(response[array_from:array_to])


class Release(Resource):
  """"Resource for single release GET request."""

  def get(self):
    parser = reqparse.RequestParser()
    parser.add_argument('release')
    args = parser.parse_args()

    return json.dumps(adapter.get_releases()[str(args['release'])])


class Labels(Resource):
  """"Resource for labels GET request."""

  def get(self):
    return json.dumps(adapter.get_labels())


class Tasks(Resource):
  """"Resource for tasks GET request."""

  def get(self):
    parser = reqparse.RequestParser()
    parser.add_argument('release')
    args = parser.parse_args()

    release_tasks = adapter.get_releases()[str(args['release'])]['tasks']
    response = []
    for task in release_tasks:
      response.append(adapter.get_tasks()['task-' + str(task)])

    return json.dumps(response)


class AirflowDBTesting(Resource):
  """Allows for SQL queries to be sent to App Engine through an HTTP GET request. FOR TESTING ONLY, WILL BE DELETED."""  # pylint: disable=line-too-long

  def get(self):
    parser = reqparse.RequestParser()
    parser.add_argument('cm')
    args = parser.parse_args()
    data = airflow_db.query(str(args['cm']))
    print type(data)

    print airflow_db.query("SELECT execution_date FROM dag_run WHERE execution_date BETWEEN '" + str(datetime.datetime.fromtimestamp(0)) + "' AND '" + str(datetime.datetime.now()) + "';")

    # return json.dumps(data)


class RestAPI(object):

  def __init__(self):
    self.releases = Releases
    self.release = Release
    self.labels = Labels
    self.tasks = Tasks
    self.airflowdb = AirflowDBTesting
