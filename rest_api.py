"""REST API"""

from flask_restful import Resource, reqparse
from filter import filter_releases, sort
from file_adapter import FileAdapter
import json

adapter = FileAdapter('fake_release_data.json', 'fake_task_data.json')
release_requests = {}


# Checks if request arguments are in cache
def in_cache(args):

    start_date = hex(int(args['start_date']))
    end_date = hex(int(args['end_date']))
    datetype = str(args['datetype'])
    state = str(int(args['state']))
    label = str(args['label'])
    sort_method = str(int(args['sort_method']))
    key = start_date + end_date + datetype + state + label + sort_method # creates an autogenerated key for memcache

    if key in release_requests:
        return key, release_requests[key]
    else:
        return False, key


class Releases(Resource):
    def get(self):
        # parse the post request for the requisite info
        parser = reqparse.RequestParser()
        parser.add_argument('start_date')
        parser.add_argument('end_date')
        parser.add_argument('datetype')
        parser.add_argument('state')
        parser.add_argument('label')
        parser.add_argument('sort_method')
        parser.add_argument('limit')
        parser.add_argument('offset')
        args = parser.parse_args()

        #check if limit and offset exists, if not, provide the first 100 releases
        if not args['limit']:
            args['limit'] = 100

        if not args['offset']:
            args['offset'] = 0

        # checks if the filtered, sorted data is already in memcache
        cache_exists, cache_results = in_cache(args)
        if cache_exists:
            return json.dumps(cache_results[int(args['offset']):(int(args['limit'])+int(args['offset']))])
        else:
            response = filter_releases(adapter.get_releases(), args['state'], args['label'], args['start_date'], args['end_date'], args['datetype'])
            response = sort(response, args['sort_method'])
            release_requests[cache_results] = response

            # time adds an expiration time of one hour, in order to keep the memcache somewhat up to date
            return json.dumps(response[int(args['offset']):(int(args['limit'])+int(args['offset']))])


class Release(Resource):
    def get(self):
        parser = reqparse.RequestParser()
        parser.add_argument('release')
        args = parser.parse_args()

        return json.dumps(adapter.get_releases()[str(args['release'])])


class Labels(Resource):
    def get(self):
        return json.dumps(adapter.get_labels())


class Tasks(Resource):
    def get(self):
        parser = reqparse.RequestParser()
        parser.add_argument('release')
        args = parser.parse_args()

        release_tasks = adapter.get_releases()[str(args['release'])]['tasks']
        response = [];
        for task in release_tasks:
            response.append(adapter.get_tasks()['task-' + str(task)])

        return json.dumps(response)


class RestAPI(object):
    def __init__(self):
        self.releases = Releases
        self.release = Release
        self.labels = Labels
        self.tasks = Tasks
