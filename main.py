from flask import Flask, jsonify, request, json, render_template, send_file, make_response, abort
from flask_restful import Api, Resource, reqparse
from google.appengine.api import memcache
import json
import filter


# creating the Flask application
app = Flask(__name__)
api = Api(app)

#--------"File Adapter"(temporary)-------#
json_data = open("fake_data.json").read()
parsed_json = json.loads(json_data)
memcache.add(key="releases", value=parsed_json)


def in_memcache(args):
    start_date = hex(int(args['start_date']))
    end_date = hex(int(args['end_date']))
    datetype = str(int(args['datetype']))
    state = str(int(args['state']))
    label = str(args['label'])
    sort_method = str(int(args['sort_method']))
    key = start_date + end_date + datetype + state + label + sort_method # creates an autogenerated key for memcache

    if memcache.get(key):
        return key, memcache.get(key)
    else:
        return False, key

def get_labels():
    if memcache.get('labels'):
        return memcache.get('labels')
    else:
        releases = memcache.get('releases')
        labels = []
        for release in releases:
            for label in releases[release]['labels']:
                if label not in labels:
                    labels.append(label)
        memcache.add(key = 'labels', value = labels, time=3600)
        return labels

#-------------------------REST API----------------------------#
class Releases(Resource):
    def get(self):
        result = memcache.get('releases')
        result = json.dumps(result)
        return result, 200


class Pagination(Resource):
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('start_date')
        parser.add_argument('end_date')
        parser.add_argument('datetype')
        parser.add_argument('state')
        parser.add_argument('label')
        parser.add_argument('sort_method')
        parser.add_argument('limit')
        parser.add_argument('offset')
        args = parser.parse_args() # this all parses the post request for the requisite info
        #check if limit and offset exists, if not, provide the first 100 releases
        if args['limit']:
            print 'limit exists'
        else:
            args['limit'] = 100
        if args['offset']:
            print 'offset exists'
        else:
            args['offset'] = 0
        # checks if the filtered, sorted data is already in memcache
        memcache_exists, memcache_results = in_memcache(args)
        if memcache_exists:
            return json.dumps(memcache_results[int(args['offset']):(int(args['limit'])+int(args['offset']))])
        else:
            response = filter.filter(memcache.get('releases'), args['state'], args['label'], args['start_date'], args['end_date'], args['datetype'])
            response = filter.sort(response, args['sort_method'])
            memcache.add(key=memcache_results, value=response, time=3600)
            # time adds an expiration time of one hour, in order to keep the memcache somewhat up to date
            return json.dumps(response[int(args['offset']):(int(args['limit'])+int(args['offset']))])

class GetLabels(Resource):
    def get(self):
        labels = get_labels()
        return json.dumps(labels)


api.add_resource(Releases, '/releases')
api.add_resource(Pagination, '/page')
api.add_resource(GetLabels, '/labels')

if __name__ == '__main__':
     app.run(port='8080', debug=True)


#---------------------Handlers-------------------------#
@app.route('/')
@app.route('/details')
def basic_pages():
    return make_response(open('templates/index.html').read())


@app.route('/getReleases')
def getReleases():
    # return render_template('details.html')
    result = memcache.get('releases')
    result = json.dumps(result)
    return result, 200

# TODO(dommarques):
#    - implement a way to log and cache all of the labels in each release
